// Copyright 2022-2024 Niantic.

using System;
using System.Diagnostics;
using System.Runtime.CompilerServices;
using System.Text;
using Niantic.Lightship.AR.Core;
using UnityEngine;

namespace Niantic.Lightship.AR.Utilities.Logging
{
    internal static class Log
    {
        private static Logger s_arLog;
        private static IntPtr s_unityContextHandle;
        private static bool s_isNativeLayerInitialised;
        private static IApi s_api = new NativeApi();

        private static LogLevel s_unityLoggerLogLevel;
        private static LogLevel s_stdLoggerLogLevel;
        private static LogLevel s_fileLoggerLogLevel;

        internal static void ConfigureLogger(IntPtr unityContextHandle, LogLevel unityLogLevel, LogLevel fileLogLevel, LogLevel stdoutLogLevel)
        {
            s_unityContextHandle = unityContextHandle;
            SetUnityLoggerLogLevel(unityLogLevel);
            SetFileLoggerLogLevel(fileLogLevel);
            SetStdOutLoggerLogLevel(stdoutLogLevel);
            LightshipUnityContext.OnDeinitialized += SwitchBackToDefaultUnityLogger;
            s_isNativeLayerInitialised = true;
        }

        private static void SwitchBackToDefaultUnityLogger()
        {
            s_isNativeLayerInitialised = false;
        }

        /// <summary>
        /// Recommended level: warning.
        /// </summary>
        /// <param name="unityLogLevel"></param>
        internal static void SetUnityLoggerLogLevel(LogLevel unityLogLevel)
        {
            s_api.ChangeUnityLoggerLogLevel(s_unityContextHandle, unityLogLevel);
            ARLog.filterLogType = LogLevelHelpers.ConvertLogLevelToUnityLogType(unityLogLevel);
            s_unityLoggerLogLevel = unityLogLevel;
        }

        /// <summary>
        /// Recommended level: Off unless you are debugging the ardk/working with niantic support about an issue
        /// </summary>
        /// <param name="fileLogLevel"></param>
        internal static void SetFileLoggerLogLevel(LogLevel fileLogLevel)
        {
            s_api.ChangeFileLoggerLogLevel(s_unityContextHandle, fileLogLevel);
            s_fileLoggerLogLevel = fileLogLevel;
        }

        /// <summary>
        /// Recommended level: Off. Mainly for internal testing
        /// </summary>
        /// <param name="stdOutLogLevel"></param>
        internal static void SetStdOutLoggerLogLevel(LogLevel stdOutLogLevel)
        {
            s_api.ChangeStdoutLoggerLogLevel(s_unityContextHandle, stdOutLogLevel);
            s_stdLoggerLogLevel = stdOutLogLevel;
        }

        private static void Message(LogType logType, string message, LogLevel logLevel, int lineNumber)
        {
            if (!ShouldPublishLog(logLevel))
            {
                return;
            }

            (string fullName, string methodName) = GetCallerFromStack(3);

            if (s_isNativeLayerInitialised)
            {
                s_api.Log(logLevel, message, fullName, lineNumber, methodName);
            }
            else
            {
                ARLog.Log(logType, message, fullName + ":" + methodName);
            }
        }


        /// <summary>
        ///   Writes a message to Unity's console via the ARDK logger.
        /// </summary>
        /// <param name="message">The message to print.</param>
        /// <param name="lineNumber">autogenerated</param>
        internal static void Info(string message, [CallerLineNumber] int lineNumber = 1)
        {
            Message(LogType.Log, message, LogLevel.Info, lineNumber);
        }

        /// <summary>
        ///   Writes a message to Unity's console via the ARDK logger.
        /// </summary>
        /// <param name="message">The message to print.</param>
        /// <param name="lineNumber">autogenerated</param>
        public static void Debug(string message, [CallerLineNumber] int lineNumber = 1)
        {
            Message(LogType.Log, message, LogLevel.Debug, lineNumber);
        }

        /// <summary>
        ///   Writes a warning message to Unity's console via the ARDK logger.
        /// </summary>
        /// <param name="message">The message to print.</param>
        /// <param name="lineNumber">autogenerated</param>
        public static void Warning(string message, [CallerLineNumber] int lineNumber = 1)
        {
            Message(LogType.Warning, message, LogLevel.Warn, lineNumber);
        }

        /// <summary>
        ///   Writes an error message to Unity's console via the ARDK logger.
        /// </summary>
        /// <param name="message">The message to print.</param>
        /// <param name="lineNumber">autogenerated</param>
        public static void Error(string message, [CallerLineNumber] int lineNumber = 1)
        {
            Message(LogType.Error, message, LogLevel.Error, lineNumber);
        }

        /// <summary>
        ///   Prints the contents of an exception and the provided context. Does not rethrow the exception
        ///   or halt execution.
        /// </summary>
        /// <param name="exception">Exception to print</param>
        /// <param name="context">Context for the exception</param>
        /// <param name="lineNumber">autogenerated</param>
        public static void Exception(Exception exception, object context = null, [CallerLineNumber] int lineNumber = 1)
        {
            (string fullName, string methodName) = GetCallerFromStack(2);

            var message = new StringBuilder().Append(exception).Append(" from context: ").Append(context).ToString();
            if (s_isNativeLayerInitialised)
            {
                s_api.Log(LogLevel.Error, message, fullName, lineNumber, methodName);
            }
            else
            {
                ARLog.Log(LogType.Exception, tag: fullName + ":" + methodName, message);
            }
        }

        /// <summary>
        /// Gets the full name (Namespace.Class) and method name of the method calling this.
        /// </summary>
        /// <param name="nestedLevel">Level of nested-ness of this call. For example, to get the direct
        ///   caller of this method, the level would be 1. To get the caller that calls this through
        ///   a helper, the level would be 2. </param>
        /// <returns>A string with the full name of the calling class, or "Niantic.Lightship" if reflection fails</returns>
        private static (string fullName, string methodName) GetCallerFromStack(int nestedLevel)
        {
            // Get the frame above the current one (the caller of this method)
            var callerFrame = new StackFrame(nestedLevel, false);

            var caller = callerFrame.GetMethod()?.ReflectedType;
            var methodName = callerFrame.GetMethod()?.Name ?? string.Empty;

            return caller == null ? ("Niantic.Lightship", string.Empty) : (caller.FullName, methodName);
        }

        /// <summary>
        /// Change the api for testing
        /// </summary>
        /// <param name="api">the mock impl to be provided here</param>
        /// <param name="newNativeLayerInitVal">bool flag to check for all code paths in the unit tests</param>
        internal static void ChangeApiForTesting(IApi api, bool newNativeLayerInitVal)
        {
            s_api = api;
            s_isNativeLayerInitialised = newNativeLayerInitVal;
        }

        private static Logger ARLog
        {
            get
            {
                return s_arLog ?? (s_arLog = new Logger(UnityEngine.Debug.unityLogger.logHandler)
                {
                    // Reduce the default logging level but allow the LogLevel property to override it after instantiation.
                    filterLogType = LogType.Warning,
                    // Disable ARDK logs based on Unity's current build mode, but allow the LogLevel property
                    // to enable them after instantiation.
                    logEnabled = true,
                });
            }
        }

        private static bool ShouldPublishLog(LogLevel logLevel)
        {
            return s_unityLoggerLogLevel <= logLevel ||
                s_fileLoggerLogLevel <= logLevel ||
                s_stdLoggerLogLevel <= logLevel;
        }
    }
}
